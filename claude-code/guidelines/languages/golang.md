# Golang ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

Go 1.26å¯¾å¿œï¼ˆ2026å¹´2æœˆãƒªãƒªãƒ¼ã‚¹ï¼‰ã€‚å…±é€šã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¯ `~/.claude/guidelines/common/` å‚ç…§ã€‚

---

## åŸºæœ¬åŸå‰‡

- **Simplicity beats complexity**: ã‚·ãƒ³ãƒ—ãƒ«ã•ã‚’æœ€å„ªå…ˆ
- **å…¬å¼ãƒ„ãƒ¼ãƒ«å¿…é ˆ**: `gofmt`, `goimports`
- **å…¬å¼ idiom å„ªå…ˆ**: ç‹¬è‡ªãƒ‘ã‚¿ãƒ¼ãƒ³ç¦æ­¢
- **Accept interfaces, return structs**
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: exported names ã«ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆ

---

## ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ

- `domain/` - ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã€å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
- `usecase/` - ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
- `interface/` - ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã€ãƒ—ãƒ¬ã‚¼ãƒ³ã‚¿ãƒ¼
- `infrastructure/` - DBã€å¤–éƒ¨API

---

## å‹å®šç¾©

### ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆ1.18+ï¼‰
- `func Map[T, R any](slice []T, fn func(T) R) []R`
- **Generic Type Aliasesï¼ˆ1.24ï¼‰**: `type Pair[T any] = struct{ A, B T }`

### æ§‹é€ ä½“è¨­è¨ˆ
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: å°æ–‡å­—é–‹å§‹ï¼ˆéå…¬é–‹ï¼‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
- getter/setter ã‚ˆã‚ŠæŒ¯ã‚‹èˆã„ãƒ¡ã‚½ãƒƒãƒ‰å„ªå…ˆ
- åŸ‹ã‚è¾¼ã¿: ã€Œis-aã€ã®ã¿

---

## å‘½åè¦å‰‡

- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸**: å°æ–‡å­—ã€å˜æ•°å½¢ã€çŸ­ãï¼ˆ`user`ï¼‰
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**: å‹•è©+erï¼ˆ`Reader`ï¼‰
- **ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿**: `New` + å‹å

---

## ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### ã‚¨ãƒ©ãƒ¼å‡¦ç†

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | ã‚³ãƒ¼ãƒ‰ | ç”¨é€” |
|---------|--------|------|
| åŸºæœ¬ | `if err != nil { return err }` | ã‚¨ãƒ©ãƒ¼ä¼æ’­ |
| ãƒ©ãƒƒãƒ— | `fmt.Errorf("msg: %w", err)` | ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ  (1.13+) |
| åˆ¤å®š | `errors.Is(err, ErrNotFound)` | ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥ç¢ºèª |
| Sentinel | `var ErrNotFound = errors.New("not found")` | å®šæ•°ã‚¨ãƒ©ãƒ¼å®šç¾© |

### ä¸¦è¡Œå‡¦ç†

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | ã‚³ãƒ¼ãƒ‰ | ç”¨é€” |
|---------|--------|------|
| goroutine | `go func() { ... }()` | ä¸¦è¡Œå®Ÿè¡Œ |
| context | `ctx, cancel := context.WithTimeout(ctx, 5*time.Second)` | ã‚­ãƒ£ãƒ³ã‚»ãƒ«åˆ¶å¾¡ |
| channel | `ch := make(chan T, bufSize)` | ãƒ‡ãƒ¼ã‚¿å—ã‘æ¸¡ã— |
| Mutex | `defer mu.Unlock()` | æ’ä»–åˆ¶å¾¡ |
| WaitGroup | `wg.Wait()` | å®Œäº†å¾…æ©Ÿ |

### ãƒ†ã‚¹ãƒˆ

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | ã‚³ãƒ¼ãƒ‰ | ç”¨é€” |
|---------|--------|------|
| åŸºæœ¬ | `func TestXxx(t *testing.T)` | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ |
| ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹• | `tests := []struct{name string; ...}` | è¤‡æ•°ã‚±ãƒ¼ã‚¹ |
| ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ | `for b.Loop() { ... }` | æ€§èƒ½æ¸¬å®š (1.24+) |
| ä¸¦è¡Œãƒ†ã‚¹ãƒˆ | `testing/synctest` | ä¸¦è¡Œã‚³ãƒ¼ãƒ‰ (1.25+) |

## ã‚ˆãã‚ã‚‹ãƒŸã‚¹

| âŒ é¿ã‘ã‚‹ | âœ… ä½¿ã† | ç†ç”± |
|----------|---------|------|
| `result, _ := db.Query()` | ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯å¿…é ˆ | ã‚¨ãƒ©ãƒ¼ç„¡è¦–ç¦æ­¢ |
| `go doWork()` (ç„¡åˆ¶é™) | `ctx` + `WaitGroup` ã§ãƒªãƒ¼ã‚¯é˜²æ­¢ | ãƒªã‚½ãƒ¼ã‚¹ç®¡ç† |
| `panic()` ã§é€šå¸¸ã‚¨ãƒ©ãƒ¼ | `return err` | ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®åŸå‰‡ |

---

## å¤ã„ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼/å®Ÿè£…æ™‚ãƒã‚§ãƒƒã‚¯ï¼‰

`go.mod` ã® `go` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–ã§å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¦ã‹ã‚‰æŒ‡æ‘˜ã™ã‚‹ã€‚

### ğŸ”´ Criticalï¼ˆå¿…ãšæŒ‡æ‘˜ï¼‰

| âŒ å¤ã„ | âœ… ãƒ¢ãƒ€ãƒ³ | Since |
|---------|----------|-------|
| `ioutil.ReadAll` | `io.ReadAll` | 1.16 |
| `ioutil.ReadFile` / `WriteFile` | `os.ReadFile` / `os.WriteFile` | 1.16 |
| `ioutil.ReadDir` | `os.ReadDir` | 1.16 |
| `ioutil.TempDir` / `TempFile` | `os.MkdirTemp` / `os.CreateTemp` | 1.16 |
| `ioutil.NopCloser` / `Discard` | `io.NopCloser` / `io.Discard` | 1.16 |
| `interface{}` | `any`ï¼ˆã¾ãŸã¯ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§å‹å®‰å…¨ã«ï¼‰ | 1.18 |

### ğŸŸ¡ Warningï¼ˆç©æ¥µçš„ã«æŒ‡æ‘˜ï¼‰

| âŒ å¤ã„ | âœ… ãƒ¢ãƒ€ãƒ³ | Since |
|---------|----------|-------|
| `sort.Slice` / `sort.Ints` / `sort.Strings` | `slices.Sort` / `slices.SortFunc` | 1.21 |
| æ‰‹å‹•ã‚¹ãƒ©ã‚¤ã‚¹ã‚³ãƒ”ãƒ¼ `copy(dst, src)` | `slices.Clone(src)` | 1.21 |
| æ‰‹å‹•ã‚¹ãƒ©ã‚¤ã‚¹æ¤œç´¢ãƒ«ãƒ¼ãƒ— | `slices.Contains(s, v)` | 1.21 |
| æ‰‹å‹•ãƒãƒƒãƒ—ã‚³ãƒ”ãƒ¼ãƒ«ãƒ¼ãƒ— | `maps.Copy(dst, src)` | 1.21 |
| è‡ªå‰ `min`/`max` é–¢æ•°å®šç¾© | ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ `min()` / `max()` | 1.21 |
| `log.Printf` (éæ§‹é€ åŒ–ãƒ­ã‚°) | `slog.Info` ç­‰ï¼ˆæ§‹é€ åŒ–ãƒ­ã‚°ï¼‰ | 1.21 |
| `for i := 0; i < n; i++`ï¼ˆå˜ç´”ã‚«ã‚¦ãƒ³ãƒˆï¼‰ | `for i := range n` | 1.22 |
| ãƒ«ãƒ¼ãƒ—å¤‰æ•° `v := v` ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚° | ä¸è¦ï¼ˆã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¯ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰ | 1.22 |
| ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒ†ãƒŠã§ `[]T` è¿”å´ | `iter.Seq[T]` ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿æä¾› | 1.23 |
| `for i := 0; i < b.N; i++` | `for b.Loop()` | 1.24 |

### â„¹ï¸ Infoï¼ˆææ¡ˆãƒ¬ãƒ™ãƒ«ï¼‰

| é …ç›® | å†…å®¹ | Since |
|------|------|-------|
| `go fix ./...` | ä¸Šè¨˜ã®å¤šãã‚’è‡ªå‹•ä¿®æ­£ã€‚å¤§é‡æ¤œå‡ºæ™‚ã¯å€‹åˆ¥ä¿®æ­£ã‚ˆã‚Šæ¨å¥¨ | 1.26 |
| `new(T, val)` | åˆæœŸå€¤ä»˜ãnew | 1.26 |

---

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- **defer** ã§ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
- **æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³** ã§ãƒã‚¹ãƒˆå›é¿
- **`any`** ã‚ˆã‚Šå…·ä½“çš„ãªå‹ or ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹
- **nil ãƒã‚§ãƒƒã‚¯** å¾¹åº•
